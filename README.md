# Redis-TCP
## Описание проекта
Приложение - аналог Redis, база данных, хранение данных в которой осуществляется в RAM. Система команд позволяет осуществить сохранение БД в файл дампа, а также выгрузить данные из указанного файла. 
Реализованы сервер и клиент. Сервер работает в многопоточном режиме.

## Использованные технологии
* С++ 17
  Обусловлено использованием `std::shared_mutex` и `std::filesystem`
* CMake
* GTest Framework
  Есть использование Test Fixtures
* spdlog
  Выбор обусловлен высокой производительностью, потокобезопасностью, а также простотой конфигурации.

## Общая архитектура проекта
### Сервер
Серверная часть приложения разделена на классы, которые отвечают за обработку различных частей логики.
Для запуска сервера необходимо передать 2 параметра - прослушиваемый порт и количество максимальных соединений соответственно.
Если указанный порт занят, то сервер перебирает все значения в интервале от `49152` до `65535` и пытается запуститься на них.
Если все порты заняты - аварийное отключение.

** Описание классов: **

* ConnectionManager
  Класс, отвечающий за обработку входящих соединений. Инициализирует сокет для прослушивания с использованием `Winsock`, а также другие необходимые параметры для работы.
  В основном цикле метода `run` ожидает входящие соединения, и если лимит подключний не превышен и всё корректно - выдает новому пользователю новый поток для обработки комманд.
  Также для отправки клиенту состояния подключения используется структура `ConnectionStatus`, которая первым параметром содержит состояние подключения, а вторым сообщение пользователю:
  ```
  struct ConnectionStatus {
    bool connected;
    char message[256];
  };
  ```
  
* CommandManager
  Класс, который отвечает за обработку команд в одтельном (для каждого пользователя) потоке.
  По хорошему надо было бы распараллелить 3 операции - чтение команды, исполнение и отправку ответа, и использовать Thread Pools, но у меня не хватило времени (
  Инициализирует доступные команды. На стороне сервера используется паттерн `Command` для полиморфизма и инкапсуляции логики работы внутри соответствующих классов.
  Все команды реализованы в отдельных классах.
  Протокол взаимодействия - строка, оканчивающаяся либо символом LF (0x0A), либо комбинацией CR LF (0x0D 0x0A). Все проверки на соответствие протоколу реализованы.
